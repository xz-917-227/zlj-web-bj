<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <script src="./CommonUtil.js"></script>
</head>
<body>
    <script charset="utf-8">

        // JS设计模式  ---  装饰者模式

        // 装饰者模式：是一种为对象添加新特性的技术(就是在保证不改变原有对象的基础上，去扩展一些想要的方法或请求)
        // 1.实现同样的接口
        // 2.需要有子类

        //  装饰者模式：子类在原始对象的基础上添加新特性 ，原始对象不做任何修改

//         var CarInterface=new BH.Interface('CarInterface',['getPrice','assemble']);
//         var Car=function(car){  //原始对象
//             // 就是为了让子类继承的 目的：让子类多一个父类的引用
//              this.car=car;
//             //  检测接口是否实现
//              BH.Interface.ensureImplements(this,CarInterface);
//         }; 
//         Car.prototype={
//             constructor:Car,
//             getPrice:function(){
//                 return 200000;
//             },
//             assemble:function(){
//                 document.write('组装汽车。。。');
//             },
//         };

//         // 如果有新的需求 比如：light,icebox。。。
// //        新特性1
//         var LightDecorrator =function(car){  //所以这里的car就继承了父类的car  是原始对象
//         // 借用构造函数继承(继承模板)  
//             LightDecorrator.superClass.constructor.call(this,car);
//         };
//         BH.extend(LightDecorrator,Car);  //原型继承(继承原型)

//         LightDecorrator.prototype={
//             constructor:LightDecorrator,
//             getPrice:function(){
//                 return this.car.getPrice()+10000;  //在原有的基础上添加
//             },
//             assemble:function(){
//                 document.write('组装汽车。。。');
//             },
//         };

//         // 新特性2
//         var IceBoxDecorator=function(car){
//             // 借用构造函数继承(继承模板)  
//             LightDecorrator.superClass.constructor.call(this,car);
//         };
//         BH.extend(IceBoxDecorator,Car);  //原型继承(继承原型)
//         IceBoxDecorator.prototype={
//             constructor:IceBoxDecorator,
//             getPrice:function(){
//                 return this.car.getPrice()+10000;  //在原有的基础上添加
//             },
//             assemble:function(){
//                 document.write('组装车载冰箱。。。');
//             },
//         };

        // 两个特性之间不会发生任何耦合，需要哪个就添加哪个，不需要就不添加

        // 检测
        // var car=new Car();
        // alert(car.getPrice());
        // car.assemble();

        // car=new LightDecorrator(car);//car是上面第一个实例
        // alert(car.getPrice());
        // car.assemble();

        // car=new IceBoxDecorator(car);//car是上面第一个实例
        // alert(car.getPrice());
        // car.assemble();


        // 装饰者模式： 不仅可以用在类，还可以用在函数上

        // 返回一个当前时间的字符串表示形式
         function getDate(){
             return (new Date()).toString();
         };

        //  包装函数 （装饰者函数）
        function upperCaseDecorator(fn){
               return function(){
                   return fn.apply(this,arguments).toUpperCase();//把原始对象全变大写形式
               };
        };

        
        alert(getDate());

      var getDecoratorDate =upperCaseDecorator(getDate);
      alert(getDecoratorDate());

    //   函数是调用
    // 对象 类 是通过new 实例的

    
    
    </script>
    
</body>
</html>