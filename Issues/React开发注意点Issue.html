<!--
 * @Author: your name
 * @Date: 2021-02-25 14:30:01
 * @LastEditTime: 2021-03-11 16:23:36
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \zlj-web-bj\Issues\React开发注意点Issue.html
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    /*

1.trunk2项目commit时不要把devInfo.js提交上去，这是每个人不同的API
2.在React框架中使用类组件，返回页面显示找render()方法，使用函数组件写法返回页面显示找return()方法
3.React使用函数为组件时  使用ant design里面的组件 都是要定义的(不需要使用this)，要区别与使用类做组件的写法
例如：使用类做组件时   制作tab切换  找到ant design中Card切换  写法如下完全可以按照ant design官访文档来写
          使用函数做组件 时要区别
 1.方法和state初始值的写法
完整案例：
 //聊天切换  标题
  const tabListNoTitle = [
    {
      key: '0',
      tab: 'article',
    },
    {
      key: '1',
      tab: 'app',
    },
    {
      key: '2',
      tab: 'project',
    },
  ];
  //聊天切换 content
  const contentListNoTitle = {
    0:  <ChatContent />,  //内容可以放在组件中   注意React中组件名开头要大写
    1: <p>app content</p>,
    2: <p>project content</p>,
  };
  //聊天内容组件  <ChatContent />  要另写一个文件，通过引入组件才有效
     函数组件最后要通过return返回会显示界面，
  写法：
  const ChatContent=()=>{
  //可以放执行操作代码
           return(
    <>   //注意要配合“<></>使用”
    //最后显示内容代码
    );
    </>
  };
//切换 tab   使用useState之前头部要引入import React,{ useState} from 'react';才有效
  const [state, onTabChange] = useState('0');//第一个参数是变量，第二个参数是方法，后面useState('0')里面的值是变量的初始值，变量的值只能在方法里改变


//组件使用
<Card
            style={{ width: '100%' }}
            tabList={tabListNoTitle}
            activeTabKey={state}
            // tabBarExtraContent={<a href="#">More</a>}
            onTabChange={key => {
              onTabChange(key);  //在这里调用方法改变state的值，把key赋给state
            }}
          >
            {contentListNoTitle[state]}
</Card>
4.const { TextArea } = Input;定义不能放在函数组件里面，
使用组件<TextArea rows={5} style={{ marginBottom: 24, }}/>注意使用style是双花括号{{}}，单个花括号是React放组件，变量的
<span className={ styles.spanInput}> 注意className是单个花括号
5.当const Select=(....);以组件形式放在在或括号里调用报错时{<Select />}，转成{Select}变量写法看看，如果Select是引进来的组件就可以这样写{<Select />}
6.使用Link组件方法：
  1.通过引入Anchor,然后定义const { Link } = Anchor;可得到Link,但是这个Link必须配合Anchor使用，否则报错。
  2. 直接通过import { Link } from 'umi';就可以直接使用Link,与Anchor无关联。
7.React.lazy懒加载组件:
  1.React.lazy方法可以异步加载组件文件
     const Foo = React.lazy(() => import('../componets/Foo));
   React.lazy不能单独使用，需要配合React.suspense，suspence是用来包裹异步组件，添加loading效果等。
     <React.Suspense fallback={<div>loading...</div>}>
        <Foo/>
     </React.Suspense>
  2. React.lazy原理
    React.lazy使用import来懒加载组件，import在webpack中最终会调用requireEnsure方法，
    动态插入script来请求js文件，类似jsonp的形式。
  8.Dva Js :https://dvajs.com/guide/
  9.export default connect与@connect:https://www.it610.com/article/1280523583495356416.htm
  10.组件里面再定义的组件，在内部也可以使用。
  11.React组件重新渲染
     1.使用Class作为组件时，改变this.state里面的值，通过调用this.setState来改变，进而重新调用render(),得到重新渲染
     2.使用函数作为组件时，使用这种方法创建变量 const [isfinished, isfinishedChange] = useState(item.isfinished == '完成于' ? true : false);
      通过调用isfinishedChange方法改变isfinished从而得到重新渲染效果，如果直接 const isfinished='';再去另外创建一个函数去改变isfinished值，是不能实现重新渲染效果的。
        因为useState相当于类组件中this.setState()的效果  所以开头要引入import React, { useState } from 'react';
        注意方法的写法：isfinishedChange(!isfinished);表明!isfinished赋给isfinished，，所以可以在外面在写一个函数去调用isfinishedChange方法。
             const checkChange=()=>{  //通过调用checkChange函数，从而调用了isfinishedChange
                isfinishedChange(!isfinished);
            };
  12.在函数中遇到return就会终止函数，把return里的值返回回去，如果没有return，就看不到渲染效果，在return里面，
      如果直接使用{变量}，要先用<></>包裹起来，否则报错
  13.在Modal中嵌套Form，要获取Form的数据，可以通过自定义Modal的footer，给按钮添加submitBtn点击事件来获取表单数据
            也可以通过，给Form添加按钮添加submitBtn点击事件来获取数据
    const [form]=Form.useForm();//获取表单 来进行数据交互
    <Modal>
      <Form form={form}>
      <Form.Item><Input /></Form.Item>
      <Form.Item><Button onClick={submitBtn} /></Form.Item>
      </Form.Item>
    </Modal>
    //提交方法
    const submitBtn = async () => {
      const fieldsValue = await form.validateFields(); // 获取form表单的值
      message.info("form的值：" + JSON.stringify(fieldsValue));//把获取到的数据转为字符串(message.info()是弹出提示信息方法)
    }
    14.在开发中，1.如果在组件里调用组件里面的组件一般使用方法的形式调用：{Method()},
                如果在组件里调用组件外面的组件一般使用组件的形式调用：<Method />
                2.一般把变量和一些方法统一都放在整个组件的外面去定义
                3.数据不能跨级获取
                4.js中新增的 `` 是用来拼写字符串，里面可以直接写变量  如 var num=2;  `输出数字：${num}`  --->结果是  输出数字：2
                5.开发一个功能或结构时，先分析--布局结构--功能要求--步骤--然后再来开发(把分析一步一步地写下来，不然容易导致开发中的思路不清晰，混乱)
                6.爬墙/翻墙：指网站访问不了(网站无法访问并不是网站本身或者网络问题，而是被“墙”挡住了，“爬墙”就是能够访问这些网站。)，被国家给屏蔽了，
                  所以通过爬墙或翻墙技术(也就是指绕过相应的IP封锁、内容过滤、域名劫持、流量限制等，实现对网络内容的访问)。
    
    */


  </script>
</body>

</html>